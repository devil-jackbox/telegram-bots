{"ast":null,"code":"import _objectSpread from\"/workspace/client/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import React,{createContext,useContext,useState,useEffect}from'react';import axios from'axios';import toast from'react-hot-toast';import{jsx as _jsx}from\"react/jsx-runtime\";const BotContext=/*#__PURE__*/createContext();export const useBots=()=>{const context=useContext(BotContext);if(!context){throw new Error('useBots must be used within a BotProvider');}return context;};export const BotProvider=_ref=>{let{children}=_ref;const[bots,setBots]=useState([]);const[loading,setLoading]=useState(true);const[error,setError]=useState(null);const api=axios.create({baseURL:process.env.NODE_ENV==='production'?'/api':process.env.REACT_APP_API_URL||'http://localhost:3001/api',timeout:10000});// Fetch all bots\nconst fetchBots=async()=>{try{setLoading(true);const response=await api.get('/bots');setBots(response.data.bots||[]);setError(null);}catch(err){var _err$response,_err$response$data;setError(((_err$response=err.response)===null||_err$response===void 0?void 0:(_err$response$data=_err$response.data)===null||_err$response$data===void 0?void 0:_err$response$data.error)||'Failed to fetch bots');toast.error('Failed to fetch bots');}finally{setLoading(false);}};// Create a new bot\nconst createBot=async botData=>{try{const response=await api.post('/bots',botData);if(response.data.success){setBots(prev=>[...prev,response.data.config]);toast.success('Bot created successfully!');return response.data;}else{throw new Error(response.data.error);}}catch(err){var _err$response2,_err$response2$data;const errorMsg=((_err$response2=err.response)===null||_err$response2===void 0?void 0:(_err$response2$data=_err$response2.data)===null||_err$response2$data===void 0?void 0:_err$response2$data.error)||err.message;toast.error(\"Failed to create bot: \".concat(errorMsg));throw err;}};// Update a bot\nconst updateBot=async(botId,updates)=>{try{const response=await api.put(\"/bots/\".concat(botId),updates);if(response.data.success){// Update with the returned bot data if available, otherwise use updates\nconst updatedBot=response.data.bot||_objectSpread({},updates);setBots(prev=>prev.map(bot=>bot.id===botId?_objectSpread(_objectSpread({},bot),updatedBot):bot));toast.success('Bot updated successfully!');return response.data;}else{throw new Error(response.data.error);}}catch(err){var _err$response3,_err$response3$data;const errorMsg=((_err$response3=err.response)===null||_err$response3===void 0?void 0:(_err$response3$data=_err$response3.data)===null||_err$response3$data===void 0?void 0:_err$response3$data.error)||err.message;toast.error(\"Failed to update bot: \".concat(errorMsg));throw err;}};// Delete a bot\nconst deleteBot=async botId=>{try{const response=await api.delete(\"/bots/\".concat(botId));if(response.data.success){setBots(prev=>prev.filter(bot=>bot.id!==botId));toast.success('Bot deleted successfully!');return response.data;}else{throw new Error(response.data.error);}}catch(err){var _err$response4,_err$response4$data;const errorMsg=((_err$response4=err.response)===null||_err$response4===void 0?void 0:(_err$response4$data=_err$response4.data)===null||_err$response4$data===void 0?void 0:_err$response4$data.error)||err.message;toast.error(\"Failed to delete bot: \".concat(errorMsg));throw err;}};// Clone a bot\nconst cloneBot=async botId=>{try{const response=await api.post(\"/bots/\".concat(botId,\"/clone\"));if(response.data.success){const newBot=response.data.bot;setBots(prev=>[...prev,newBot]);toast.success('Bot cloned successfully!');return newBot;}else{throw new Error(response.data.error);}}catch(err){var _err$response5,_err$response5$data;const errorMsg=((_err$response5=err.response)===null||_err$response5===void 0?void 0:(_err$response5$data=_err$response5.data)===null||_err$response5$data===void 0?void 0:_err$response5$data.error)||err.message;toast.error(\"Failed to clone bot: \".concat(errorMsg));throw err;}};// Start a bot\nconst startBot=async botId=>{try{const response=await api.post(\"/bots/\".concat(botId,\"/start\"));if(response.data.success){setBots(prev=>prev.map(bot=>bot.id===botId?_objectSpread(_objectSpread({},bot),{},{status:'running'}):bot));toast.success('Bot started successfully!');return response.data;}else{throw new Error(response.data.error);}}catch(err){var _err$response6,_err$response6$data;const errorMsg=((_err$response6=err.response)===null||_err$response6===void 0?void 0:(_err$response6$data=_err$response6.data)===null||_err$response6$data===void 0?void 0:_err$response6$data.error)||err.message;toast.error(\"Failed to start bot: \".concat(errorMsg));throw err;}};// Stop a bot\nconst stopBot=async botId=>{try{const response=await api.post(\"/bots/\".concat(botId,\"/stop\"));if(response.data.success){setBots(prev=>prev.map(bot=>bot.id===botId?_objectSpread(_objectSpread({},bot),{},{status:'stopped'}):bot));toast.success('Bot stopped successfully!');return response.data;}else{throw new Error(response.data.error);}}catch(err){var _err$response7,_err$response7$data;const errorMsg=((_err$response7=err.response)===null||_err$response7===void 0?void 0:(_err$response7$data=_err$response7.data)===null||_err$response7$data===void 0?void 0:_err$response7$data.error)||err.message;toast.error(\"Failed to stop bot: \".concat(errorMsg));throw err;}};// Get bot logs\nconst getBotLogs=async function(botId){let options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};try{const params=new URLSearchParams(options);const response=await api.get(\"/bots/\".concat(botId,\"/logs?\").concat(params));return response.data.logs||[];}catch(err){toast.error('Failed to fetch bot logs');return[];}};// Get bot errors\nconst getBotErrors=async function(botId){let options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};try{const params=new URLSearchParams(options);const response=await api.get(\"/bots/\".concat(botId,\"/errors?\").concat(params));return response.data.errors||[];}catch(err){toast.error('Failed to fetch bot errors');return[];}};// Get supported languages\nconst getSupportedLanguages=async()=>{try{// Force JavaScript only on the client\nreturn[{id:'javascript',name:'JavaScript',extension:'js'}];}catch(err){return[{id:'javascript',name:'JavaScript',extension:'js'}];}};// Get bot file content\nconst getBotFile=async botId=>{try{const response=await api.get(\"/files/\".concat(botId));return response.data;}catch(err){toast.error('Failed to fetch bot file');throw err;}};// Update bot file content\nconst updateBotFile=async(botId,content)=>{try{const response=await api.put(\"/files/\".concat(botId),{content});if(response.data.success){toast.success('Bot file updated successfully!');return response.data;}else{throw new Error(response.data.error);}}catch(err){var _err$response8,_err$response8$data;const errorMsg=((_err$response8=err.response)===null||_err$response8===void 0?void 0:(_err$response8$data=_err$response8.data)===null||_err$response8$data===void 0?void 0:_err$response8$data.error)||err.message;toast.error(\"Failed to update bot file: \".concat(errorMsg));throw err;}};// Get a single bot\nconst getBot=async botId=>{try{const response=await api.get(\"/bots/\".concat(botId));if(response.data.success){// Update the bot in the local state\nsetBots(prevBots=>{const existingBot=prevBots.find(b=>b.id===botId);if(existingBot){return prevBots.map(b=>b.id===botId?response.data.bot:b);}else{return[...prevBots,response.data.bot];}});return response.data.bot;}else{throw new Error(response.data.error);}}catch(err){var _err$response9,_err$response9$data;const errorMsg=((_err$response9=err.response)===null||_err$response9===void 0?void 0:(_err$response9$data=_err$response9.data)===null||_err$response9$data===void 0?void 0:_err$response9$data.error)||err.message;toast.error(\"Failed to fetch bot: \".concat(errorMsg));throw err;}};useEffect(()=>{fetchBots();},[]);const value={bots,loading,error,fetchBots,createBot,updateBot,deleteBot,startBot,stopBot,cloneBot,getBot,getBotLogs,getBotErrors,getSupportedLanguages,getBotFile,updateBotFile};return/*#__PURE__*/_jsx(BotContext.Provider,{value:value,children:children});};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}